<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fantasy Universe • 3-D Orbit Demo</title>
<style>
  body   { margin:0; background:#000; overflow:hidden }
  canvas { display:block }
  .label { color:#fff; font:11px/1 sans-serif; pointer-events:none }
</style>
</head>
<body>

<!-- ───────────────── import-map ───────────────── -->
<script type="importmap">
{
  "imports": {
    "three"         : "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "dat.gui"       : "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js",
    "seedrandom"    : "https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/+esm",
    "CSS2DRenderer" : "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/renderers/CSS2DRenderer.js"
  }
}
</script>

<script type="module">
/* ───────── imports ───────── */
import * as THREE                     from "three";
import { OrbitControls }              from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js";
import { GUI }                        from "dat.gui";
import seedrandom                     from "seedrandom";
import { CSS2DRenderer, CSS2DObject } from "CSS2DRenderer";

/* ───────── deterministic RNG ───────── */
const rng  = seedrandom(42);
const rand = () => rng();

/* ───────── user config ───────── */
const masses=[2.38968133,1.48497179,2.61821438,2.18289368,0.55427884,2.93418035,
2.35507720,2.42237362,0.64590681,1.51604203,1.30115467,2.80226547,2.03843582,
2.52145636,1.49721834,0.91354455,1.79737892,0.47230659,2.53460416,2.00549388,
2.34683690,1.25722011,2.92088467,2.71142703,2.40163544,0.82552451,1.56014671,
0.41827017,0.71658163,2.14423217,2.31085782,2.91227628,1.17972847,1.30024121,
1.56780069,0.81157267,0.65078806];

const explicitSizes=[2.90121319,2.78650555,1.18628174,2.89756445,1.86119798,
2.21525832,3.64765924,1.17396666,1.49593912,1.29246725,3.29124753,2.88821351,
1.66062238,1.34903475,2.91163706,1.52016542,1.76303995,2.90625306,1.17601191,
1.83562532,2.36732968,2.70277592,2.07735455,3.68071612,3.07360163,1.01405609,
1.89170146,1.05420676,3.27384817,1.29814726,1.98306991,3.14525563,2.03611594,
1.07184258,1.7049766 ,1.89937133,2.52821855];

const R0=10, ALPHA=40, BASE_SPEED=5.0;
const SAFETY=10, PUSH_K=0.04;

/* disc parameters */
const DISC_OUTER_RADIUS = 130;
const DISC_OPACITY      = 0.15;

/* orbit-path look */
const ORBIT_SEGMENTS = 128;
const ORBIT_OPACITY  = 1.0;

/* ───────── scene & renderers ───────── */
const scene  = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(100,0,0); camera.up.set(0,0,1);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(innerWidth,innerHeight);
labelRenderer.domElement.style.position="absolute";
labelRenderer.domElement.style.top="0";
labelRenderer.domElement.style.pointerEvents="none";
document.body.appendChild(labelRenderer.domElement);

/* ─── NEW: simulation-time readout bottom-right ─── */
const timeDiv = document.createElement('div');
timeDiv.style.cssText = `
  position:absolute;
  bottom:6px; right:10px;
  color:#fff; font:12px monospace;
  pointer-events:none`;
timeDiv.textContent = 't = 0.0';
document.body.appendChild(timeDiv);
let simTime = 0;  // cumulative simulated seconds
/* ──────────────────────────────────────────────── */

/* controls */
const controls = new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true; controls.dampingFactor=0.05;
controls.enablePan=false;
controls.minPolarAngle=0.001; controls.maxPolarAngle=Math.PI-0.001;

/* lighting + central orb */
scene.add(new THREE.AmbientLight(0xffffff,0.4));
scene.add(new THREE.PointLight(0xffffff,1.2));
scene.add(new THREE.Mesh(new THREE.SphereGeometry(4,32,32),
                         new THREE.MeshBasicMaterial({color:0xffffff})));

/* ───────── three-ring disc ───────── */
const discMeshes=[];
(function addDisc(){
  const rings=[
    {r1:0,r2:DISC_OUTER_RADIUS/3,color:0xffffff},
    {r1:DISC_OUTER_RADIUS/3,r2:2*DISC_OUTER_RADIUS/3,color:0x00ff00},
    {r1:2*DISC_OUTER_RADIUS/3,r2:DISC_OUTER_RADIUS,color:0x0000ff}
  ];
  rings.forEach(cfg=>{
    const geom=new THREE.RingGeometry(cfg.r1,cfg.r2,128);
    const mat =new THREE.MeshBasicMaterial({
      color:cfg.color,side:THREE.DoubleSide,transparent:true,opacity:DISC_OPACITY
    });
    const mesh=new THREE.Mesh(geom,mat);
    discMeshes.push(mesh); scene.add(mesh);
  });
})();

/* ───────── helpers ───────── */
const xyz=(r,th,i,O)=>{
  const x_op=r*Math.cos(th), y_op=r*Math.sin(th);
  const x1=x_op, y1=y_op*Math.cos(i), z1=y_op*Math.sin(i);
  return { x:x1*Math.cos(O)-y1*Math.sin(O),
           y:x1*Math.sin(O)+y1*Math.cos(O),
           z:z1 };
};


/* ----------------- tier-aware name generator -----------------
   – lowest ⅓ masses  → soft syllables
   – middle ⅓ masses  → neutral syllables
   – highest ⅓ masses → harsh syllables
---------------------------------------------------------------- */

function makeNameFactory(masses){
  /* split masses by tertile */
  const sorted = [...masses].sort((a,b)=>a-b);
  const t1 = sorted[Math.floor(sorted.length/3)];
  const t2 = sorted[Math.floor(2*sorted.length/3)];

  /* syllable pools */
  const inner  = [ "li", "lo", "lu", "ba", "ca", "ce", "ci", "da", 
  "du", "fa", "fi",  "fu", "ga", "ma", "me", "mi", "mo", "na", "ne", 
  "ni", "no", "pa", "pe", "pi", "ra",  "ro", "ru", "sa", "se", "so", 
  "su", "ta", "ti",  "tu", "va", "ve", "cia", "gio", "tia", "rio",
  "lua", "sio", "dra", "tre",  "cai", "mau", "leo",  "nua", "sia", 
  "lue", "rio", "ciel", "lune", "sole"];
  const mid   = ["ai", "ao", "ara", "ari", "aya", "ayu", "eha", "ela", 
  "ena", "era", "ero", "esa", "eso", "fia", "fua", "hai",  "hea", 
  "hira", "hui", "ia", "ihi", "ira", "iri", "isa", "ishi", "iya", 
  "iwi", "lae", "lei",  "li",  "mi", "rai", "ra", "ja", "ria", "ri", 
  "rui", "sai",  "sha", "shi", "sia", "sya", "tai", "tei", "tia", 
  "tra", "uia", "ula", "una", "uri", "wai", "wia", "xia", "ya", "yai", 
  "yui", "yura", "zai",  "zua", "zya", "wa", "ya", "ye", "ko", "ku", 
  "sa", "ha", "cha", "che", "chi", "cho", "chu", "qua", "que", "qui", 
  "quo", "sha", "she", "shi", "sho", "ska", "ske", "ski", "sko", "tha", 
  "the", "thi", "tho", "tsa", "tse", "tsi", "tso", "nava", "hoka",
  "waka", "yata", "paya", "cata", "luta", "mana", "sapa", "tala"
];
  const outer = ["ar", "arn", "bal", "bjorn", "blot", "borg", "brann", 
    "dal", "dalf", "drak", "eik", "eld", "fenn", "fjell", "flod", 
    "frid", "gard", "grim", "grom", "gud", "haf", "haug", "heim", 
    "holm", "horn", "hraf", "huld", "isk", "jord", "jot", "kald", 
    "karl", "kjell", "knut", "kyst", "lag", "lind", "lod", "lund", 
    "lyng", "mork", "myr", "natt", "nord", "orf", "orsk", "run", 
    "ryg", "sag", "skar", "skjold", "skol", "skog", "sol", "sval", 
    "sven", "sver", "thor", "tind", "tjor", "torv", "troll", "tryg", 
    "ulf", "ulv", "valk", "vald", "vind", "vis", "volk", "vorn", "ygg",
    "ymir", "ørn", "åre", "årk", "ård", "ægir", "ødeg", "ølf", "ørk",
    "åsen", "åker", "ålv", "åd"
];

  /* seeded RNG already in scope: rand() */
  function pick(arr){ return arr[rand()*arr.length|0]; }

  return function genName(mass){
    const pool = mass<=t1 ? inner : mass<=t2 ? mid : outer;
    let name = pick(pool) + pick(pool);  // always 2 syllables
    if (rand() < 0.25) name += pick(pool); // sometimes 3
    if (rand() < 0.10) name += pick(pool); // rarely 4
    return name.charAt(0).toUpperCase() + name.slice(1);
  };
}

/* build once, then call for every planet */
const genName = makeNameFactory(masses);
const planetNames = masses.map(m => genName(m));

/* arrays for toggling */
const orbitLines=[], nameLabels=[];


/* ───────── planet factory ───────── */
function makePlanet(idx,mass,size,offset){
  const rOrbit = R0 + ALPHA*mass;
  const omega  = BASE_SPEED / rOrbit;
  const inc    = rand()*Math.PI/4;
  const Omega  = rand()*2*Math.PI;
  const theta0 = offset;

  /* sphere */
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size,20,20),
    new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(rand(),0.8,0.55)})
  );
  scene.add(mesh);

  /* orbit path */
  const pts=[];
  for(let k=0;k<=ORBIT_SEGMENTS;k++){
    const t=(k/ORBIT_SEGMENTS)*2*Math.PI;
    pts.push(new THREE.Vector3(...Object.values(xyz(rOrbit,t,inc,Omega))));
  }
  const path=new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pts),
    new THREE.LineBasicMaterial({color:0x555555,transparent:false,opacity:ORBIT_OPACITY})
  );
  orbitLines.push(path); scene.add(path);

  /* name label */
  const div=document.createElement('div');
  div.className="label"; div.textContent=planetNames[idx];
  const label=new CSS2DObject(div);
  label.position.set(0,0,+size*1.1+1);
  mesh.add(label); nameLabels.push(label);

//   return {mass,size,rOrbit,omega,inc,Omega,theta:theta0,mesh};
  return {mass,size,rOrbit,omega,inc,Omega,theta0,theta:theta0,mesh};

}

const sizes   = explicitSizes ?? masses.map(m=>m);
const planets = masses.map((m,i)=>makePlanet(i,m,sizes[i],i*2*Math.PI/masses.length));


/* ───────── GUI ───────── */
// const params={speed:1, showDisc:true, showOrbits:true, showNames:true};
const params={
  speed:0,
  seekTime:0,
  showDisc:true,
  showOrbits:true,
  showNames:true
};
const gui=new GUI();
gui.add(params,'speed',0,20,0.1).name('sim speed');
gui.add(params,'showDisc').name('show disc')
   .onChange(v=>discMeshes.forEach(m=>m.visible=v));
gui.add(params,'showOrbits').name('show paths')
   .onChange(v=>orbitLines.forEach(l=>l.visible=v));
gui.add(params,'showNames').name('show names')
   .onChange(v=>nameLabels.forEach(lbl=>lbl.visible=v));
gui.add(params,'seekTime').name('seek to t')
   .onFinishChange(t=>{
       simTime = Math.max(0, Number(t) || 0);
       // reposition every planet for new time
       planets.forEach(p=>{
          p.theta = p.theta0 + p.omega * simTime;
          p.pos   = xyz(p.rOrbit, p.theta, p.inc, p.Omega);
          p.mesh.position.set(p.pos.x,p.pos.y,p.pos.z);
       });
       timeDiv.textContent = `t = ${simTime.toFixed(1)}`;
   });

/* ───────── animation ───────── */
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta()*params.speed;

  /* update sim time & UI */
  simTime += dt;
  timeDiv.textContent = `t = ${simTime.toFixed(1)}`;

  /* ----- planet motion, repulsion, rendering (unchanged) ----- */
  planets.forEach(p=>{ p.theta+=p.omega*dt; p.pos=xyz(p.rOrbit,p.theta,p.inc,p.Omega); });

  for(let i=0;i<planets.length;i++){
    for(let j=i+1;j<planets.length;j++){
      const a=planets[i],b=planets[j];
      const dx=a.pos.x-b.pos.x,dy=a.pos.y-b.pos.y,dz=a.pos.z-b.pos.z;
      const dist2=dx*dx+dy*dy+dz*dz;
      const min=(a.size+b.size)*SAFETY;
      if(dist2<min*min && params.speed>0){
        const push=PUSH_K/dist2;
        a.theta+=push; b.theta-=push;
        a.pos=xyz(a.rOrbit,a.theta,a.inc,a.Omega);
        b.pos=xyz(b.rOrbit,b.theta,b.inc,b.Omega);
      }
    }
  }

  planets.forEach(p=>p.mesh.position.set(p.pos.x,p.pos.y,p.pos.z));
  controls.update();
  renderer.render(scene,camera);
  labelRenderer.render(scene,camera);
}
animate();

/* responsive */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  labelRenderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
